#then loop through the rest of the matrix compare possible values (look at the formula in blue above)
for (i in 2:nrow(amatrix)){
for (j in 2:ncol(amatrix)){
amatrix[i,j] <- max(amatrix[i-1,j-1]+scoreMat[i-1, j-1], amatrix[i-1,j]+GAP_SCORE, amatrix[i,j-1]+GAP_SCORE, 0)
}
}
return(amatrix)
}
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
MATCH_SCORE <- 3
MISMATCH_SCORE <- 1
GAP_SCORE <- -2
# create the score matrix mapping
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
# create the score matrix
x <- "CGTGAATTCAT"
y <- "GACTTAC"
scoreMat <- lut[strsplit(y,"")[[1]], strsplit(x,"")[[1]]]
# create the alignment matrix
alignmentMat <- alignmentMatrix(x, y, scoreMat)
# predefined constant
GAP_SCORE <- -2
alignmentMatrix<-function(seq1,seq2, scoreMat){
#convert seq1 and seq2 strings to vector
seq1 <- strsplit(seq1, "")[[1]]
seq2 <- strsplit(seq2, "")[[1]]
amatrix <- matrix(0, ncol=length(seq1)+1, nrow=length(seq2)+1) #initialize alignment matrix
rownames(amatrix) <-c("", seq2) #set row names
colnames(amatrix) <-c("", seq1) #set column names
#set the values of the 1st row and column
amatrix[1,] <- seq(0, -2*(ncol(amatrix)-1), by=-2)
amatrix[,1] <- seq(0, -2*(nrow(amatrix)-1), by=-2)
#then loop through the rest of the matrix compare possible values (look at the formula in blue above)
for (i in 2:nrow(amatrix)){
for (j in 2:ncol(amatrix)){
amatrix[i,j] <- max(amatrix[i-1,j-1]+scoreMat[i-1, j-1], amatrix[i-1,j]+GAP_SCORE, amatrix[i,j-1]+GAP_SCORE)
}
}
return(amatrix)
}
MATCH_SCORE <- 3
MISMATCH_SCORE <- 1
GAP_SCORE <- -2
# create the score matrix mapping
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
# create the score matrix
x <- "CGTGAATTCAT"
y <- "GACTTAC"
scoreMat <- lut[strsplit(y,"")[[1]], strsplit(x,"")[[1]]]
# create the alignment matrix
alignmentMat <- alignmentMatrix(x, y, scoreMat)
alignmentMat
createScoreMatrix <- function(seq1, seq2, MATCH_SCORE, MISMATCH_SCORE){
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
scoreMat <- lut[strsplit(seq1,"")[[1]], strsplit(seq2,"")[[1]]]
return(scoreMat)
}
localAlignmentMatrix<-function(seq1,seq2, MATCH_SCORE, MISMATCH_SCORE, GAP_SCORE){
# create score matrix
scoreMat <- createScoreMatrix(seq1, seq2, MATCH_SCORE, MISMATCH_SCORE)
#convert seq1 and seq2 strings to vector
seq1 <- strsplit(seq1, "")[[1]]
seq2 <- strsplit(seq2, "")[[1]]
amatrix <- matrix(0, ncol=length(seq1)+1, nrow=length(seq2)+1) #initialize alignment matrix
rownames(amatrix) <-c("", seq1) #set row names
colnames(amatrix) <-c("", seq2) #set column names
#set the values of the 1st row and column
amatrix[1,] <- numeric(length=ncol(amatrix))
amatrix[,1] <- numeric(length=nrow(amatrix))
#then loop through the rest of the matrix compare possible values (look at the formula in blue above)
for (i in 2:nrow(amatrix)){
for (j in 2:ncol(amatrix)){
amatrix[i,j] <- max(amatrix[i-1,j-1]+scoreMat[i-1, j-1], amatrix[i-1,j]+GAP_SCORE, amatrix[i,j-1]+GAP_SCORE, 0)
}
}
return(amatrix)
}
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
scoreMat <- lut[strsplit(seq1,"")[[1]], strsplit(seq2,"")[[1]]]
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
scoreMat <- lut[strsplit("AGCCTATGGCTTATGATCCA","")[[1]], strsplit("TTAGACAGGGCTTAAGCT","")[[1]]]
scoreMat
lut <- matrix(-1, 4, 4)
diag(lut) <- 3
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
scoreMat <- lut[strsplit("AGCCTATGGCTTATGATCCA","")[[1]], strsplit("TTAGACAGGGCTTAAGCT","")[[1]]]
scoreMat
seq1 <- strsplit("AGCCTATGGCTTATGATCCA", "")[[1]]
seq2 <- strsplit("TTAGACAGGGCTTAAGCT", "")[[1]]
createScoreMatrix <- function(seq1, seq2, MATCH_SCORE, MISMATCH_SCORE){
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))
scoreMat <- lut[strsplit(seq1,"")[[1]], strsplit(seq2,"")[[1]]]
return(scoreMat)
}
localAlignmentMatrix<-function(seq1,seq2, MATCH_SCORE, MISMATCH_SCORE, GAP_SCORE){
# create score matrix
scoreMat <- createScoreMatrix(seq1, seq2, MATCH_SCORE, MISMATCH_SCORE)
#convert seq1 and seq2 strings to vector
seq1 <- strsplit(seq1, "")[[1]]
seq2 <- strsplit(seq2, "")[[1]]
amatrix <- matrix(0, nrow=length(seq1)+1, ncol=length(seq2)+1) #initialize alignment matrix
rownames(amatrix) <-c("", seq1) #set row names
colnames(amatrix) <-c("", seq2) #set column names
#set the values of the 1st row and column
amatrix[1,] <- numeric(length=ncol(amatrix))
amatrix[,1] <- numeric(length=nrow(amatrix))
#then loop through the rest of the matrix compare possible values (look at the formula in blue above)
for (i in 2:nrow(amatrix)){
for (j in 2:ncol(amatrix)){
amatrix[i,j] <- max(amatrix[i-1,j-1]+scoreMat[i-1, j-1], amatrix[i-1,j]+GAP_SCORE, amatrix[i,j-1]+GAP_SCORE, 0)
}
}
return(amatrix)
}
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
MATCH <- 3
MISMATCH <- -1
GAP <- -3
sub <- nucleotideSubstitutionMatrix(match=MATCH, mismatch=MISMATCH, baseOnly=TRUE) #creates DNA substitution matrix
knitr::opts_chunk$set(comment = "")
library(seqinr)
library(Biostrings)
source("pairAlign.R")
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
MATCH <- 3
MISMATCH <- -1
GAP <- -3
sub <- nucleotideSubstitutionMatrix(match=MATCH, mismatch=MISMATCH, baseOnly=TRUE) #creates DNA substitution matrix
pairAlign("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", substitutionMatrix=sub, gapExtension=GAP, type="local")
knitr::opts_chunk$set(comment = "")
library(seqinr)
library(Biostrings)
source("pairAlign.R")
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
MATCH <- 3
MISMATCH <- -1
GAP <- -3
sub <- nucleotideSubstitutionMatrix(match=MATCH, mismatch=MISMATCH, baseOnly=TRUE) #creates DNA substitution matrix
pairAlign("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", substitutionMatrix=sub, gapExtension=GAP, type="local")
knitr::opts_chunk$set(comment = "")
library(seqinr)
library(Biostrings)
source("pairAlign.R")
MATCH <- 3
MISMATCH <- -1
GAP <- -3
localAlignmentMatrix("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", MATCH, MISMATCH, GAP)
MATCH <- 3
MISMATCH <- -1
GAP <- -3
sub <- nucleotideSubstitutionMatrix(match=MATCH, mismatch=MISMATCH, baseOnly=TRUE) #creates DNA substitution matrix
pairAlign("AGCCTATGGCTTATGATCCA", "TTAGACAGGGCTTAAGCT", substitutionMatrix=sub, gapExtension=GAP, type="local")
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric()
for(i in 1:len(permutations)){
perm <- permutations[i]
curr_align_score <- pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE)
scores[i] <- curr_align_score
}
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric()
for(i in 1:length(permutations)){
perm <- permutations[i]
curr_align_score <- pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE)
scores[i] <- curr_align_score
}
scores
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
for(i in 1:length(permutations)){
perm <- permutations[i]
curr_align_score <- pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE)
scores[i] <- curr_align_score
}
scores
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
for(i in 1:length(permutations)){
perm <- permutations[i]
curr_align_score <- pairAlign(perm, "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE)
scores[i] <- curr_align_score
}
scores
?hist
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores")
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", density=TRUE)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", density)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=TRUE)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
## Initialization
n <- length(sequences)
pattern <- matrix("", n, n)
subject <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(peptides[i], peptides[j], "BLOSUM62", gapOpening=-6, gapExtension=-3)
pattern[j, i] <- alignment[[1]]
subject[i, j] <- alignment[[1]]
subject[j, i] <- alignment[[2]]
pattern[i, j] <- alignment[[2]]
}
}
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE")
## Initialization
n <- length(sequences)
pattern <- matrix("", n, n)
subject <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", gapOpening=-6, gapExtension=-3)
pattern[j, i] <- alignment[[1]]
subject[i, j] <- alignment[[1]]
subject[j, i] <- alignment[[2]]
pattern[i, j] <- alignment[[2]]
}
}
pattern
subject
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE") #these are the sequences that you should be working with.
## Initialization
n <- length(sequences)
align1 <- matrix("", n, n)
align2 <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", -8, -2)
align1[j, i] <- alignment[[1]]
align2[i, j] <- alignment[[1]]
align2[j, i] <- alignment[[2]]
align1[i, j] <- alignment[[2]]
}
}
distances <- sapply(mapply(`!=`, strsplit(align1, ""), strsplit(align2, "")), sum)
distanceMatrix <- matrix(distances, n, n)
dimnames(distanceMatrix) = list(sequences, sequences)
distanceMatrix
## Initialization
n <- length(sequences)
align1 <- matrix("", n, n)
align2 <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", -8, -2)
align1[j, i] <- alignment[[1]]
align2[i, j] <- alignment[[1]]
align2[j, i] <- alignment[[2]]
align1[i, j] <- alignment[[2]]
}
}
distances <- sapply(mapply(`!=`, strsplit(align1, ""), strsplit(align2, "")), sum)
distanceMatrix <- matrix(distances, n, n)
dimnames(distanceMatrix) = list(sequences, sequences)
distanceMatrix
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE") #these are the sequences that you should be working with.
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE") #these are the sequences that you should be working with.
distanceMatrix
distanceMatrix
colSums(distanceMatrix)
min(colSums(distanceMatrix))
which.min(colSums(distanceMatrix))
cSum <- colSums(distanceMatrix)
which.min(cSum)
cSum <- colSums(distanceMatrix)
cSum
which.min(cSum)
cSum <- colSums(distanceMatrix)
cSum
class(which.min(cSum))
cSum <- colSums(distanceMatrix)
class(cSum)
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the column with the minimum distance in cSum
which.min(cSum)
patterns <- strsplit(align1[,center][-center], "")
subjects <- strsplit(align2[,center][-center], "")
patterns
subjects
center = "PMCWGHVE"
buildMSA(patterns, subjects, center)
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the column with the minimum distance in cSum
which.min(cSum)[0]
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the column with the minimum distance in cSum
which.min(cSum)[1]
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the column with the minimum distance in cSum
which.min(cSum)[2]
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the column with the minimum distance in cSum
which.min(cSum)[[1]]
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the index of the column with the minimum distance in cSum
center = which.min(cSum)[[1]]
buildMSA(patterns, subjects, center)
MATCH <- 3
MISMATCH <- -1
GAP <- -3
sub <- nucleotideSubstitutionMatrix(match=MATCH, mismatch=MISMATCH) #creates DNA substitution matrix
pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="global")
pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="global")
# generate permutations
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
# loop through each permutation
for(i in 1:length(permutations)){
perm <- permutations[i]
# compute alignment score
curr_align_score <- pairAlign(perm, "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE)
# add to scores vector
scores[i] <- curr_align_score
}
head(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
len(scores[scores >= -24]) / len(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
length(scores[scores >= -24]) / length(scores)
knitr::opts_chunk$set(comment = "")
library(seqinr)
library(Biostrings)
source("pairAlign.R")
#modified version of generateSeqsWithMultinomialModel() from https://a-little-book-of-r-for-bioinformatics.readthedocs.io/en/latest/src/chapter4.html
generateSeqs <- function(inputsequence, X){
#split inputted string into vector of individual characters
inputsequencevector <- strsplit(inputsequence,"")[[1]]
mylength <- length(inputsequencevector)
mytable <- table(inputsequencevector)
letters <- rownames(mytable)
probabilities <- mytable/mylength #store the probabilities of letters
#sample total number of characters needed to generate X random sequences of length myLength
seqset <- sample(letters, mylength*X, rep=TRUE, prob=probabilities)
#apply paste0() to collapse vector of characters into a vector of character strings of the original length
seqs <- vapply(seq(1, mylength*X, mylength), function(i) paste0(seqset[i:(i+(mylength-1))], collapse = ''), inputsequence)
return(seqs)
}
pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="local")
pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="global")
# generate permutations
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
# loop through each permutation
for(i in 1:length(permutations)){
perm <- permutations[i]
# compute alignment score
curr_align_score <- pairAlign(perm, "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE, type="global")
# add to scores vector
scores[i] <- curr_align_score
}
head(scores)
pairAlign("MVWHDVDEGFHTAVW", "HDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="local")
# generate permutations
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
# loop through each permutation
for(i in 1:length(permutations)){
perm <- permutations[i]
# compute alignment score
curr_align_score <- pairAlign(perm, "HDVGVWGHDD", gapOpening=-10, gapExtension=-2, substitutionMatrix="BLOSUM62", scoreOnly=TRUE, type="local")
# add to scores vector
scores[i] <- curr_align_score
}
head(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
length(scores[scores >= -24]) / length(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
length(scores[scores >= 18]) / length(scores)
# sum the columns of the distance matrix
cSum <- colSums(distanceMatrix)
# find the index of the column with the minimum distance in cSum
center = which.min(cSum)[[1]]
center
## Initialization
n <- length(sequences)
pattern <- matrix("", n, n)
subject <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", gapOpening=-6, gapExtension=-3)
pattern[j, i] <- alignment[[1]]
subject[i, j] <- alignment[[1]]
subject[j, i] <- alignment[[2]]
pattern[i, j] <- alignment[[2]]
}
}
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE")
## Initialization
n <- length(sequences)
pattern <- matrix("", n, n)
subject <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", gapOpening=-6, gapExtension=-3)
pattern[j, i] <- alignment[[1]]
subject[i, j] <- alignment[[1]]
subject[j, i] <- alignment[[2]]
pattern[i, j] <- alignment[[2]]
}
}
pattern
subject
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE") #these are the sequences that you should be working with.
## Initialization
n <- length(sequences)
align1 <- matrix("", n, n)
align2 <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", -8, -2)
align1[j, i] <- alignment[[1]]
align2[i, j] <- alignment[[1]]
align2[j, i] <- alignment[[2]]
align1[i, j] <- alignment[[2]]
}
}
distances <- sapply(mapply(`!=`, strsplit(align1, ""), strsplit(align2, "")), sum)
distanceMatrix <- matrix(distances, n, n)
dimnames(distanceMatrix) = list(sequences, sequences)
distanceMatrix
distances <- sapply(mapply(`!=`, strsplit(patterns, ""), strsplit(subjects, "")), sum)
sequences <- c("PVWHTAE", "HEVGAWGHEE", "PMCWGHVE") #these are the sequences that you should be working with.
## Initialization
n <- length(sequences)
pattern <- matrix("", n, n)
subject <- align1
## Generate alignments
for(i in 1:(n-1)) {
for(j in (i+1):n) {
alignment <- pairAlign(sequences[i], sequences[j], "BLOSUM62", gapOpening=-6, gapExtension=-3)
pattern[j, i] <- alignment[[1]]
subject[i, j] <- alignment[[1]]
subject[j, i] <- alignment[[2]]
pattern[i, j] <- alignment[[2]]
}
}
pattern
subject
distances <- sapply(mapply(`!=`, strsplit(pattern, ""), strsplit(subject, "")), sum)
distanceMatrix <- matrix(distances, n, n)
dimnames(distanceMatrix) = list(sequences, sequences)
distanceMatrix
possibleCenters <- which(colSums(distanceMatrix) == min(colSums(distanceMatrix)))
center <- possibleCenters[which.max(nchar(sequences[possibleCenters]))]
center
knitr::opts_chunk$set(comment = "")
library(seqinr)
library(Biostrings)
source("pairAlign.R")
pairAlign("MVWHDVDEGFHTAVW", "AHDVGVWGHDD", substitutionMatrix="BLOSUM62", gapOpening=-12, gapExtension=-3, type="local")
# generate permutations
permutations <- generateSeqs("MVWHDVDEGFHTAVW", 2000)
scores <- numeric(2000)
# loop through each permutation
for(i in 1:length(permutations)){
perm <- permutations[i]
# compute alignment score
curr_align_score <- pairAlign(perm, "AHDVGVWGHDD", gapOpening=-12, gapExtension=-3, substitutionMatrix="BLOSUM62", scoreOnly=TRUE, type="local")
# add to scores vector
scores[i] <- curr_align_score
}
head(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
length(scores[scores >= 18]) / length(scores)
hist(scores, xlab="Alignment Score", ylab="Frequency", main="Histogram of Alignment Scores", freq=FALSE)
# probability calculation
length(scores[scores >= 18]) / length(scores)
