map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
# function that will take in as its argument a nucleotide sequence and then return its GC content
GC_Content <- function(seq){
return((sum(sequence == "g")+sum(sequence == "c")) / length(seq))
}
GC_Content(Ecoli_seq)
# Write a pair of functions called frequencyPyrimidine() and frequencyPurine() such that, given a nucleotide sequence, they will output the respective frequencies of pyrimidines and purines
frequencyPyrimidine <- function(sequence){
counts <- table(sequence)
return(counts[["c"]] + counts[["t"]])
}
frequencyPurine <- function(sequence){
counts <- table(sequence)
return(counts[["a"]] + counts[["g"]])
}
# Write a pair of functions called frequencyPyrimidine() and frequencyPurine() such that, given a nucleotide sequence, they will output the respective frequencies of pyrimidines and purines
frequencyPyrimidine <- function(sequence){
counts <- table(sequence)
return(counts[["c"]] + counts[["t"]])
}
frequencyPurine <- function(sequence){
counts <- table(sequence)
return(counts[["a"]] + counts[["g"]])
}
frequencyPyrimidine(c("c"))
# determine the total number of nucleotides in the E_coli genome sequence
Ecoli_seq <- E_coli[[1]]
numNucleotides <- length(Ecoli_seq)
numNucleotides
z<-c("a","b","c")
which(z=="b")
head(Ecoli_seq)
class(Ecoli_seq)
table(Ecoli_seq)
sum(Ecoli_seq == "c")
# Write a pair of functions called frequencyPyrimidine() and frequencyPurine() such that, given a nucleotide sequence, they will output the respective frequencies of pyrimidines and purines
frequencyPyrimidine <- function(sequence){
return(sum(sequence == "c") + sum(sequence == "t"))
}
frequencyPurine <- function(sequence){
return(sum(sequence == "a") + sum(sequence == "g"))
}
frequencyPyrimidine(c("c"))
# Write a pair of functions called frequencyPyrimidine() and frequencyPurine() such that, given a nucleotide sequence, they will output the respective frequencies of pyrimidines and purines
frequencyPyrimidine <- function(sequence){
return(sum(sequence == "c") + sum(sequence == "t"))
}
frequencyPurine <- function(sequence){
return(sum(sequence == "a") + sum(sequence == "g"))
}
# given a nucleotide sequence, outputs its weight
seqWeight <- function(sequence, type="DNA"){
if(type == "RNA"){
return(sum(sequence == "a")*329.2 + sum(sequence == "c")*305.2 + sum(sequence == "g")*345.2 + sum(sequence == "u")*306.2)
}
else {
return(sum(sequence == "a")*313.2 + sum(sequence == "c")*289.2 + sum(sequence == "g")*329.2 + sum(sequence == "t")*304.2)
}
}
# Output weight of the following DNA sequence
seq <- c("g", "a", "t", "a", "t", "t", "c", "g", "g", "a", "g", "g", "g", "g")
seqWeight(seq)
# given a DNA sequence, output the complementary strand
compStrand <- function(seq){
map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
# function that will take in as its argument a nucleotide sequence and then return its GC content
GC_Content <- function(seq){
return((sum(seq == "g")+sum(seq == "c")) / length(seq))
}
GC_Content(Ecoli_seq)
GC(Ecoli_seq)
install.packages("seqinr", repos='http://cran.us.r-project.org')
library("seqinr")
E_coli <- read.fasta(file="E_coli.fasta")
# given a nucleotide sequence, outputs its weight
seqWeight <- function(sequence, type="DNA"){
if(type == "RNA"){
return(sum(sequence == "a")*329.2 + sum(sequence == "c")*305.2 + sum(sequence == "g")*345.2 + sum(sequence == "u")*306.2)
}
else {
return(sum(sequence == "a")*313.2 + sum(sequence == "c")*289.2 + sum(sequence == "g")*329.2 + sum(sequence == "t")*304.2)
}
}
# Output weight of the following DNA sequence
seq <- c("g", "a", "t", "a", "t", "t", "c", "g", "g", "a", "g", "g", "g", "g")
seqWeight(seq)
# given a DNA sequence, output the complementary strand
compStrand <- function(seq){
map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
# function that will take in as its argument a nucleotide sequence and then return its GC content
GC_Content <- function(seq){
return((sum(seq == "g")+sum(seq == "c")) / length(seq))
}
GC_Content(Ecoli_seq)
GC(Ecoli_seq)
#  takes a nucleotide sequence’s length, a window size, and a step size as arguments and outputs a sequence of numbers containing the starting nucleotide position of each window that fully fits within the sequence
windowStartPositions <- function(len, windowSize, stepSize){
return(seq(1, len-windowSize+1, by=stepSize))
}
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:startPos[i]+windowSize-1])
}
return(GC)
}
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
print(windowStarts)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide)
}
plotSlidingGC(Ecoli_seq, 4000, 4000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide)
}
plotSlidingGC(Ecoli_seq, 4000, 4000)
# given a DNA sequence, output the complementary strand
compStrand <- function(seq){
map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
compStrand(c("A","T", "G"))
# given a DNA sequence, output the complementary strand
compStrand <- function(seq){
map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
#  takes a nucleotide sequence’s length, a window size, and a step size as arguments and outputs a sequence of numbers containing the starting nucleotide position of each window that fully fits within the sequence
windowStartPositions <- function(len, windowSize, stepSize){
return(seq(1, len-windowSize+1, by=stepSize))
}
seq(1, 5, 2)
#  takes a nucleotide sequence’s length, a window size, and a step size as arguments and outputs a sequence of numbers containing the starting nucleotide position of each window that fully fits within the sequence
windowStartPositions <- function(len, windowSize, stepSize){
return(seq(1, len-windowSize+1, by=stepSize))
}
windowStartPositions(10, 5, 2)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
print(GC_slide)
plot(windowStarts, GC_slide)
}
plotSlidingGC(Ecoli_seq, 1000000, 1000000)
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:startPos[i]+windowSize-1])
}
return(GC)
}
slidingGC(Ecoli_seq[1:100], 10, 10)
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:startPos[i]+windowSize-1])
print(seq[startPos[i]:startPos[i]+windowSize-1])
}
return(GC)
}
slidingGC(Ecoli_seq[1:100], 10, 10)
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:(startPos[i]+windowSize-1)])
print(seq[startPos[i]:startPos[i]+windowSize-1])
}
return(GC)
}
slidingGC(Ecoli_seq[1:100], 10, 10)
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:(startPos[i]+windowSize-1)])
print(seq[startPos[i]:(startPos[i]+windowSize-1)])
}
return(GC)
}
slidingGC(Ecoli_seq[1:100], 10, 10)
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:(startPos[i]+windowSize-1)])
}
return(GC)
}
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
print(GC_slide)
plot(windowStarts, GC_slide)
}
plotSlidingGC(Ecoli_seq, 1000000, 1000000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
print(GC_slide)
plot(windowStarts, GC_slide)
}
plotSlidingGC(Ecoli_seq, 100000, 100000)
#--for Q1
id <- c("ENO2", "TDH3", "RPL39", "GAL4", "POL12", "EST2") #protein codes
protName <- c("enolase", "glyceraldehyde-3-phosphate dehydrogenase", "60S ribosomal protein L39", "regulatory protein Gal4", "DNA polymerase subunit alpha B", "telomerase reverse transcriptase") #full protein names
abundance <- c(24563, 22369, 16232, 32.3, 13.7, 0.01) #cellular abundance in ppm
length <- c(437, 332, 51, 881, 705, 884) #number of amino acids
yeastProt <- data.frame(id, protName, abundance, length)
#--for Q2 and onwards
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager") #installs Bioconductor
BiocManager::install("multtest") #uses Bioconductor's installation tool to install the multtest package
rm(list())
rm(list = ls())
# find the row that contains the data for cyclin D3
cycD3_row <- grep("cyclin D3", golub.gnames[,2], ignore.case = TRUE)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o')
}
plotSlidingGC(Ecoli_seq, 100000, 100000)
#--for Q1
id <- c("ENO2", "TDH3", "RPL39", "GAL4", "POL12", "EST2") #protein codes
protName <- c("enolase", "glyceraldehyde-3-phosphate dehydrogenase", "60S ribosomal protein L39", "regulatory protein Gal4", "DNA polymerase subunit alpha B", "telomerase reverse transcriptase") #full protein names
abundance <- c(24563, 22369, 16232, 32.3, 13.7, 0.01) #cellular abundance in ppm
length <- c(437, 332, 51, 881, 705, 884) #number of amino acids
yeastProt <- data.frame(id, protName, abundance, length)
#--for Q2 and onwards
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager") #installs Bioconductor
BiocManager::install("multtest") #uses Bioconductor's installation tool to install the multtest package
library(multtest) #loads a library of tools included in the multtest package, including the golub data
data(golub) #loads the golub data set
#yeastProt[yeastProt[,3] > 500, 3]
#yeastProt[,1]
#yeastProt[1,]
#yeastProt[1:3,c(1,3)]
#yeastProt[1,1]
# Rewrite the above command (yeastProt[yeastProt[,3] > 500, 3]) with two different notations for data frame indexing that generate the same output.
yeastProt[1:3, "abundance"]
yeastProt$abundance[1:3]
# Construct a command that generates a new data frame named filteredyeastProt that consists of information from proteins with an abundance greater than 21000 ppm.
filteredyeastProt <- yeastProt[yeastProt[,"abundance"] > 21000,]
filteredyeastProt
# Using the information encoded in golub.cl, which columns in the golub matrix represent patients with ALL and which columns represent patients with AML?
# 1 codes for AML; 0 for ALL
# patients with AML
AML_pats <- which(golub.cl == 1)
AML_pats
# patients with ALL
ALL_pats <- which(golub.cl == 0)
ALL_pats
# find the row that contains the data for cyclin D3
cycD3_row <- grep("cyclin D3", golub.gnames[,2], ignore.case = TRUE)
cycD3_row
# calculate the mean expression of cyclin D3 mRNA in ALL patients and then in AML patients
cycD3_ALL <- mean(golub[cycD3_row, ALL_pats])
cycD3_ALL
cycD3_AML <- mean(golub[cycD3_row, AML_pats])
cycD3_AML
# Run the t-test on cyclin D3 expression values, report the p-value, and interpret its meaning
t.test(golub[cycD3_row,ALL_pats],golub[cycD3_row,AML_pats])
meanALL2 <- apply(golub[,ALL_pats], 1, mean)
# second apply command to compute the mean expression of each gene for AML patients
meanAML2 <- apply(golub[,AML_pats], 1, mean)
# the absolute value of the difference in means between ALL and AML patients
absDiff <- abs(meanALL2 - meanAML2)
# return the names of the 7 genes that have the largest absolute difference in mean expression between ALL and AML patients
o <- order(absDiff, decreasing=TRUE)
golub.gnames[o[1:7], 2]
gol.fac <- factor(golub.cl, levels=c(0,1), labels = c("ALL","AML"))
gol.fac
# makes a scatter plot of the gene expression data of the 1042th gene in the golub database. The patients are on the x-axis, and the respective gene expression is on the y-axis.
# first argument adds the data to the plot
plot(golub[1042,])
# pch=2 -- changes the specific character that will be plotted. Switches from circles to triangles
plot(golub[1042,], pch=2)
# col=28 -- changes the color of the points plotted to blue
plot(golub[1042,], col=28)
# type='l' -- changes the type of plot to a line graph
plot(golub[1042,], type='l')
# lty=2 -- changes the solid line to dashed line
plot(golub[1042,], type='l', lty=2)
# xlab="patient index" -- adds x label to the graph
# ylab="normalized cyclin D3 expression" -- adds y label to the graph
plot(golub[1042,], col=28, xlab="patient index", ylab="normalized cyclin D3 expression")
# main="Example of plotting in R" -- adds a title to the plot
plot(golub[1042,], col=28, xlab="patient index", ylab="normalized cyclin D3 expression",main="Example of plotting in R")
stripchart(golub[1042,] ~ gol.fac, main="Cyclin D3 expression in ALL and AML patients", xlab="Patient cancer subtype", ylab="Normalized cyclin D3 expression", method="jitter", vertical=TRUE)
# create a scatter plot of the gene expression values for two genes that are used as subtype predictors: IL-8 (row 2663 of golub) and IL-8 precursor (row 2664)
plot(golub[2663,], golub[2664,], col=gol.fac, xlab="IL-8 expression", ylab="IL-8 precursor expression", main="Correlation between IL-8 and IL-8 precursor")
# create a scatter plot of the gene expression values for two genes that are used as subtype predictors: IL-8 (row 2663 of golub) and Zyxin (row 2124)
plot(golub[2663,], golub[2124,], col=gol.fac, xlab="IL-8 expression", ylab="Zyxin expression", main="Correlation between IL-8 and Zyxin")
# histogram of the expression of cyclin D3 in ALL patients
hist(golub[1042,gol.fac=="ALL"], freq=FALSE, xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in ALL")
# overlay the normal distribution curve
curve(dnorm(x, mean=mean(golub[1042,gol.fac=="ALL"]), sd=sd(golub[1042,gol.fac=="ALL"])), add=TRUE)
# Use the par() function to display this plot and the plot of cyclin D3 expression in ALL from 3.4 in a 2x1 array (2 rows and 1 column).
par(mfrow=c(2, 1))
# plot a histogram and normal curve for the distribution of normalized cyclin D3 expression in ALL.
hist(golub[1042,gol.fac=="ALL"], freq=FALSE, xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in ALL")
curve(dnorm(x, mean=mean(golub[1042,gol.fac=="ALL"]), sd=sd(golub[1042,gol.fac=="ALL"])), add=TRUE)
# plot a histogram and normal curve for the distribution of normalized cyclin D3 expression in AML.
hist(golub[1042,gol.fac=="AML"], freq=FALSE, xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in AML")
curve(dnorm(x, mean=mean(golub[1042,gol.fac=="AML"]), sd=sd(golub[1042,gol.fac=="AML"])), add=TRUE)
# Use the par() function to display this plot and the plot of cyclin D3 expression in ALL from 3.4 in a 2x1 array (2 rows and 1 column).
par(mfrow=c(2, 1))
# plot a histogram and normal curve for the distribution of normalized cyclin D3 expression in ALL.
hist(golub[1042,gol.fac=="ALL"], freq=FALSE, xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in ALL", xlim=c(-1,3))
curve(dnorm(x, mean=mean(golub[1042,gol.fac=="ALL"]), sd=sd(golub[1042,gol.fac=="ALL"])), add=TRUE)
# plot a histogram and normal curve for the distribution of normalized cyclin D3 expression in AML.
hist(golub[1042,gol.fac=="AML"], freq=FALSE, xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in AML", xlim=c(-1,3))
curve(dnorm(x, mean=mean(golub[1042,gol.fac=="AML"]), sd=sd(golub[1042,gol.fac=="AML"])), add=TRUE)
# determine how many genes with the label “oncogene” are in the gene expression data set
onc <- grep("oncogene", golub.gnames[,2], ignore.case=TRUE)
numOnc <- length(onc)
numOnc
# Which of the oncogenes is the most highly differentially expressed?
index <- onc[order(absDiff[onc], decreasing=TRUE)[1]]
golub.gnames[index, 2]
# Is this gene in the top 50 highly differentially expressed genes from the whole data set?
index %in% order(absDiff, decreasing=TRUE)[1:50]
boxplot(golub[1042,] ~ gol.fac, main="Cyclin D3 expression in ALL and AML patients", xlab="Patient cancer subtype", ylab="Normalized cyclin D3 expression")
# create main plot with ALL data
plot(density(golub[1042,gol.fac=="ALL"]), xlim=c(-1,3), xlab="Normalized cyclin D3 expression", main="Distribution of normalized cyclin D3 expression in leukemia patients", col=3)
# overlay AML data
lines(density(golub[1042,gol.fac=="AML"]), col=4)
# add a legend
legend(x=-1,y=0.7, legend=c("ALL","AML"),pch=15, col=c(3,4))
install.packages("seqinr", repos='http://cran.us.r-project.org')
library("seqinr")
E_coli <- read.fasta(file="E_coli.fasta")
# Define a vector in R called myvec containing the integers between 7 and 21
myvec <- c(7:21)
# use indexing to replace the third entry of myvec with the character string “Hi”
myvec[3] <- "Hi"
print(myvec)
# Write a function that takes in a list and prints out what type of object is stored in each element of the list
element_type <- function(lst){
for (element in lst){
print(class(element))
}
}
# determine the total number of nucleotides in the E_coli genome sequence
Ecoli_seq <- E_coli[[1]]
numNucleotides <- length(Ecoli_seq)
numNucleotides
# Print out the last 200 nucleotides of the E_coli genome sequence
NUM_NUCLEOTIDES <- 200
Ecoli_seq[(length(Ecoli_seq)-NUM_NUCLEOTIDES+1):length(Ecoli_seq)]
# Find the individual nucleotide counts for the E_coli genome
counts <- table(Ecoli_seq)
counts
# What would the counts be for a DNA strand complimentary to this one
countsComplement <- table(c("a", "c", "g", "t"))
# set values in table countComplements
countsComplement[["a"]] = counts[["t"]]
countsComplement[["t"]] = counts[["a"]]
countsComplement[["g"]] = counts[["c"]]
countsComplement[["c"]] = counts[["g"]]
countsComplement
# Write a pair of functions called frequencyPyrimidine() and frequencyPurine() such that, given a nucleotide sequence, they will output the respective frequencies of pyrimidines and purines
frequencyPyrimidine <- function(sequence){
return((sum(sequence == "c") + sum(sequence == "t")) / length(sequence))
}
frequencyPurine <- function(sequence){
return((sum(sequence == "a") + sum(sequence == "g")) / length(sequence))
}
# given a nucleotide sequence, outputs its weight
seqWeight <- function(sequence, type="DNA"){
if(type == "RNA"){
return(sum(sequence == "a")*329.2 + sum(sequence == "c")*305.2 + sum(sequence == "g")*345.2 + sum(sequence == "u")*306.2)
}
else {
return(sum(sequence == "a")*313.2 + sum(sequence == "c")*289.2 + sum(sequence == "g")*329.2 + sum(sequence == "t")*304.2)
}
}
# Output weight of the following DNA sequence
seq <- c("g", "a", "t", "a", "t", "t", "c", "g", "g", "a", "g", "g", "g", "g")
seqWeight(seq)
# given a DNA sequence, output the complementary strand
compStrand <- function(seq){
map=c("A"="T", "T"="A","G"="C","C"="G")
compl <- seq
for(i in 1:length(compl)){
compl[i] <- as.character(map[seq[i]])
}
return(rev(compl))
}
# function that will take in as its argument a nucleotide sequence and then return its GC content
GC_Content <- function(seq){
return((sum(seq == "g")+sum(seq == "c")) / length(seq))
}
GC_Content(Ecoli_seq)
GC(Ecoli_seq)
#  takes a nucleotide sequence’s length, a window size, and a step size as arguments and outputs a sequence of numbers containing the starting nucleotide position of each window that fully fits within the sequence
windowStartPositions <- function(len, windowSize, stepSize){
return(seq(1, len-windowSize+1, by=stepSize))
}
#  takes a nucleotide sequence, a window size, and a step size as arguments and outputs a numeric vector containing the GC content of each window
slidingGC <- function(seq, windowSize, stepSize){
startPos <- windowStartPositions(length(seq), windowSize, stepSize)
GC <- startPos
for(i in 1:length(startPos)){
GC[i] <- GC_Content(seq[startPos[i]:(startPos[i]+windowSize-1)])
}
return(GC)
}
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o')
}
plotSlidingGC(Ecoli_seq, 100000, 100000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o')
}
plotSlidingGC(Ecoli_seq, 100000, 10000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o')
}
plotSlidingGC(Ecoli_seq, 100000, 10000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o', xlab="Start Nucleotide Index", ylab="Window GC Content", main="GC Content of Window vs Start Nucleotide Index")
}
plotSlidingGC(Ecoli_seq, 100000, 10000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o', xlab="Start Nucleotide Index", ylab="Window GC Content", main="GC Content of Window vs Start Nucleotide Index")
}
plotSlidingGC(Ecoli_seq, 50000, 10000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o', xlab="Start Nucleotide Index", ylab="Window GC Content", main="GC Content of Window vs Start Nucleotide Index")
}
plotSlidingGC(Ecoli_seq, 500000, 10000)
# takes a nucleotide sequence, a window size, and a step size as arguments and plots a scatter plot of the GC content of each window against the starting nucleotide position of each window
plotSlidingGC <- function(seq, windowSize, stepSize){
windowStarts <- windowStartPositions(length(seq), windowSize, stepSize)
GC_slide <- slidingGC(seq, windowSize, stepSize)
plot(windowStarts, GC_slide, pch='.', type='o', xlab="Start Nucleotide Index", ylab="Window GC Content", main="GC Content of Window vs Start Nucleotide Index")
}
plotSlidingGC(Ecoli_seq, 5000, 10000)
?plot
# Write a function that takes in a list and prints out what type of object is stored in each element of the list
element_type <- function(lst){
for (element in lst){
print(class(element))
}
}
motleyCrew <- list(char = c("a", "b", "c"), num = 1:7, func = sample, logic = TRUE, missing = NA, numberList = list(one = 1, two = 2, three = 3))
element_type(motleyCrew)
