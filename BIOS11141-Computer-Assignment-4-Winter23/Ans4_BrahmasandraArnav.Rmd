
## Computer Assignment 4 Answers File
---
Please write your answers into the space below the questions. Knit this file when you are done to check that all code runs. Remember to rename the file to contain *your actual* Last and First name.
---
```{r}
# IMPORTING LIBRARIES
library(seqinr)
library(Biostrings)
source("pairAlign_cpp.R")
```


<span style="color:green"> 1.1 <br> </span> 
<span style="color:blue"> 
The byrow argument is filling in the data by row into the matrix, while by default it fills in by column.
</span>


<span style="color:green"> 1.2 \span
```{r}
# supplying the data argument with MORE elements than the matrix
matrix(data = 1:25, nrow = 3, ncol = 3)
```
```{r}
# supplying the data argument with LESS elements than the matrix
matrix(data = 1:4, nrow = 3, ncol = 3)
```

<span style="color:blue">
When the data argument contains more elements than the matrix does, R just cuts the data by taking the first elements and fills until the matrix is full. When the data argument contains less elements than the matrix, R just repeats the data until the matrix is full.
</span>


<span style="color:green"> 1.3 \span
```{r}
x <- matrix(data = 1:25, nrow = 5, ncol = 5)

mean(x)
sd(x)
sum(x)
```
<span style="color:blue">
R performs these calculations on all of the elements in the matrix
</span>


<span style="color:green"> 1.4 \span
```{r}
testMatrix <- matrix(nrow = 2, ncol = 4, data = 1:8)
dim(testMatrix)
```
<span style="color:blue">
The first element of the vector returned by dim is the number of rows, and the second element is the number of columns.
</span>

<span style="color:green"> 1.5 \span
```{r}
# initialize test matrix
x <- matrix(nrow = 4, ncol = 4, data = 1:16)

# replace each element with new value
NEW_VALUE <- 3
for (i in 1:nrow(x)){
  for (j in 1:ncol(x)){
    x[i,j] <- NEW_VALUE
  }
}
x
```


<span style="color:green"> 1.6 \span
```{r}
x <- matrix(nrow = 3, ncol = 3, data = 1:9)
x
```
```{r}
for(i in 1:ncol(x)) {
  for(j in 1:nrow(x)) {
    print(x[i,j])
  }
}
```

<span style="color:blue">
The elements of the matrix are printed by row (i.e. the first row is printed from left to right, then the second row, etc.)
</span>


<span style="color:green"> 1.7 \span
```{r}
# function that calculates the standard deciation for each of the rows and returns the result as a vector
rowSD <- function(matrix){
  c <- numeric(length = nrow(matrix))
  for (i in 1:nrow(matrix)){
    c[i] <- sd(matrix[i,])
  }
  return(c)
}

testMatrix <- matrix(nrow = 3, ncol = 3, data = 1:9)
rowSD(testMatrix)
```


<span style="color:green"> 1.8 \span
```{r}
testMatrix %*% testMatrix
```
<span style="color:blue">
This operation returns the matrix that is outputted from the matrix multiplication of testMatrix with itself.
</span>


<span style="color:green"> 2.1 <br> \span
<span style="color:blue">
a) +3 +3 +3 -4 +1 +3 +3 = 12
<br>
b) +3 +3 -4 +3 +3 -4 -4 = 0
<br>
c) +3 +3 +1 +3 -4 +3 -4 -4 = 1
</span>


<span style="color:green"> 2.2 <br> \span
<span style="color:blue"> 
The strings are being split into a vector. Each character of the string becomes an element in the vector.
</span>


<span style="color:green"> 2.3 <br> \span
<span style="color:blue">
Uploaded to Canvas
</span>

<span style="color:green"> 2.4 \span
```{r}
# predefined constant
GAP_SCORE <- -2

alignmentMatrix<-function(seq1,seq2, scoreMat){
  
  #convert seq1 and seq2 strings to vector
  seq1 <- strsplit(seq1, "")[[1]]
  seq2 <- strsplit(seq2, "")[[1]]
  
  
  amatrix <- matrix(0, ncol=length(seq1)+1, nrow=length(seq2)+1) #initialize alignment matrix
  rownames(amatrix) <-c("", seq2) #set row names
  colnames(amatrix) <-c("", seq1) #set column names
  
  #set the values of the 1st row and column
  amatrix[1,] <- seq(0, -2*(ncol(amatrix)-1), by=-2)
  amatrix[,1] <- seq(0, -2*(nrow(amatrix)-1), by=-2)
  
  #then loop through the rest of the matrix compare possible values (look at the formula in blue above)
  for (i in 2:nrow(amatrix)){
    for (j in 2:ncol(amatrix)){
      amatrix[i,j] <- max(amatrix[i-1,j-1]+scoreMat[i-1, j-1], amatrix[i-1,j]+GAP_SCORE, amatrix[i,j-1]+GAP_SCORE)
    }
  }
  
  return(amatrix)
}
```

<span style="color:green"> 2.5 \span
```{r}
MATCH_SCORE <- 3
MISMATCH_SCORE <- 1
GAP_SCORE <- -2

# create the score matrix mapping
lut <- matrix(MISMATCH_SCORE, 4, 4)
diag(lut) <- MATCH_SCORE
dimnames(lut) <- list(c("A", "C", "G", "T"), c("A", "C", "G", "T"))

# create the score matrix
x <- "CGTGAATTCAT"
y <- "GACTTAC"
scoreMat <- lut[strsplit(y,"")[[1]], strsplit(x,"")[[1]]]

# create the alignment matrix
alignmentMat <- alignmentMatrix(x, y, scoreMat)
alignmentMat
```

<span style="color:blue">
The score of the optimal mapping is +9. The answer matches what I obtained by hand.  
</span>


<span style="color:green"> 2.6 <br> \span
<span style="color:blue">
Using the image from above there are 3 possible tracebacks

1) <br>
"GATC-CA" <br>
"GATTACA" <br>

2) <br>
"GAT-CCA" <br>
"GATTACA" <br>

3) <br>
"GA-TCCA" <br>
"GATTACA" <br>
</span>


<span style="color:green"> 2.8 \span
```{r}
# produce the alignment for the two nucleotide sequences “GATTACACCTAGGT” and “GATCCAACGTC”
# SCORE SYSTEM
MATCH_SCORE <- 3
MISMATCH_SCORE <- -1
GAP_SCORE <- -2

sub <- nucleotideSubstitutionMatrix(match = MATCH_SCORE, mismatch = MISMATCH_SCORE, baseOnly = TRUE) #creates DNA substitution matrix
pairAlign("GATTACACCTAGGT", "GATCCAACGTC", substitutionMatrix = sub, gapExtension = GAP_SCORE, type = "global")
```

<span style="color:green"> 2.9 \span
```{r}
# produce the alignment for the two nucleotide sequences “GATTACACCTAGGT” and “GATCCAACGTC”

# SCORE SYSTEM
MATCH_SCORE <- 5
MISMATCH_SCORE <- -2
GAP_SCORE <- -3

sub <- nucleotideSubstitutionMatrix(match = MATCH_SCORE, mismatch = MISMATCH_SCORE, baseOnly = TRUE) #creates DNA substitution matrix

pairAlign("GATTACACCTAGGT", "GATCCAACGTC", substitutionMatrix = sub, gapExtension = GAP_SCORE, type = "global")
```

<span style="color:green"> 2.10 <br> \span
<span style="color:blue">
I got the exact same alignments for both of the questions above. The only difference was in the scores of the alignments.
</span>

<span style="color:green"> 2.11 <br> \span

<span style="color:blue">
Evolutionary, it makes sense because one large gap is much more likely than many small gaps. It is plausible that one large gap could be caused by a single insertion of DNA, whereas multiple gaps requires multiple openings/insertions into the DNA.
</span>

<span style="color:green"> 2.12 \span
```{r}
# gapOpening and gapExtension are respectively set to: -1 and -1
pairAlign("MVWHVWHLAGNPI", "HDVGVWGVWHGVAK", substitutionMatrix="BLOSUM62", gapOpening = -1, gapExtension = -1, type = "global")

# gapOpening and gapExtension are respectively set to: -1 and -4
pairAlign("MVWHVWHLAGNPI", "HDVGVWGVWHGVAK", substitutionMatrix="BLOSUM62", gapOpening = -1, gapExtension = -4, type = "global")

# gapOpening and gapExtension are respectively set to: -10 and -2
pairAlign("MVWHVWHLAGNPI", "HDVGVWGVWHGVAK", substitutionMatrix="BLOSUM62", gapOpening = -10, gapExtension = -2, type = "global")
```
<span style="color:blue">
In the first alignment, gap openings/extensions are not penalized that much, so there are many more gaps than the other 2 alignments. In the second alignment, gap extension is penalized more than opening, which justifies the fact that there is a gap that is broken up by a single amino acid. In the last alignment, gap openings are penalized much more than alignment, so the number of gaps is minimized compared to the other 2. 
</span>

```{r}
source("ORF.R")
ecoli <- seqinr::read.fasta("E_coli.fasta")[[1]]
findORF(ecoli[1:10000], 100)
```

<span style="color:green"> 3.1 \span
```{r}
# Use findORF() to find the ORFs that have a minimum length of 100 codons in the forward strand of the E. coli genome, and store it in a variable E-coli-ORF
Ecoli_ORF <- findORF(ecoli, 100)
```

<span style="color:green"> 3.2 \span
```{r}
# Sort the rows of ecoliORF by ORF length
Ecoli_ORF_sorted <- Ecoli_ORF[order(Ecoli_ORF$Length, decreasing = T),]
```


<span style="color:green"> 3.3a \span
```{r}
# Use the head() function on your sorted data frame to output the first few longest ORFs in the forward strand of the E coli genome

head(Ecoli_ORF_sorted)
```


<span style="color:green"> 3.3b <br> \span
<span style="color:blue"> 
The second longest gene codes for ATP-dependant helicase Lhr. Lhr's function is to translocate 3' to 5' on single stranded DNA.
</span>


<span style="color:green"> 3.4a <br> \span

```{r}
# calculate the ORFs of length >= 200 nucleotide in the forward and reverse strand of the Staphylococcus aureus genome

staph <- seqinr::read.fasta("Staphylococcus_sequence.fasta")[[1]]
forward <- findORF(staph, 200)
reverse <- findORF(compStrand(staph), 200)

head(forward)
head(reverse)
```

<span style="color:green"> 3.4b <br> </span>

<span style="color:blue">
The number of ORFs calculated through the code is 850 + 807 = 1657 open reading frames. This is less than the number of proteins coded (around 2,800 proteins). Since Staph is a bacteria, many proteins can be produced by cutting up one translated "protein" using the bacteria's proteases. This could account for the many more proteins coded for than translated ORFs.
</span>

<span style="color:green"> 3.4c \span

<span style="color:blue">
According to NCBI, Staph has around 2,700 ORFs in its genome, which is pretty similar to the number of proteins. This number does account for the number of proteins coded in the genome. Maybe, our code didn't account for certain scenarios and missed some ORFs because of that. 
</span>
